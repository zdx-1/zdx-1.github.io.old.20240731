<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>线性动态规划问题&amp;背包问题进阶策略详解 | Zdx-1</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Zdx-1" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>线性动态规划问题&amp;背包问题进阶策略详解</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-05-06T03:30:54.000Z" id="date"> 2024-05-06</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-05-17T11:01:38.000Z" id="updated"> 2024-05-17</time></div></span></div></div><hr><div id="post-content"><h2 id="1-DP-概述"><a href="#1-DP-概述" class="headerlink" title="1. DP 概述"></a>1. DP 概述</h2><p>DP（dynamic Progamming），动态规划算法，是一类常见、常考的算法。</p>
<p>在算法竞赛中，DP的考法多而杂，并且难度可以从简单到超难，主要难在状态的设计，以及思考如何转移；但是在蓝桥杯比赛中，涉及到的往往都是简单，基础的DP考点，十分考验基本功。</p>
<p>动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。</p>
<p>在算法类竞赛中，计数等非最优化问题的递推解法也常被不规范地称作 DP。</p>
<h2 id="2-主要思想以及条件"><a href="#2-主要思想以及条件" class="headerlink" title="2. 主要思想以及条件"></a>2. 主要思想以及条件</h2><p>DP 将原问题划分划分为若干个重叠的子问题，并且逐层递进，每个子问题在求解的过程中，都会被抽象为“阶段”，也叫做“状态”，在完成前一个阶段的计算后，才能进行下一阶段的计算。</p>
<p>最广泛运用的例子就是数字三角形问题：</p>
<p>给定一个三角形，第 $i$ 行有 $i$ 个元素，如下图：</p>
<p>​       <span> 5 </span><br>​     <span> 5 </span> <span> 4 </span><br>   <span> 8 </span> <span> 9 </span> <span> 0 </span></p>
<p>你初始在第一行的第一个元素位置，每一次，可以选择左下，或者右下的位置进行移动，每次移动到一个位置上，可以获得相应的分数。问：你可以任意规划自己的路线，请问在走到最后一行时，能够获得的最大分数是多少？</p>
<p>同学们可以自行计算一下，当然，很多同学可以一眼看出来，答案是 $5 + 5 + 9 &#x3D; 19$。从第一行开始，往左边，然后往右边。</p>
<p>如果利用动态规划的思想，应该如下考虑：</p>
<p>而对于每一个点，它的下一步决策只有两种：往左下角或者往右下角（如果存在）。因此只需要记录当前点的最大权值，用这个最大权值执行下一步决策，来更新后续点的最大权值。<strong>即，对于每一个点，当作一种状态，代表的意义是：到达当前点能累积的最大分数。</strong></p>
<p>如果你理解了这一步，并且认为其设计的十分有道理，那么我们来剖析一下其中原理：</p>
<h3 id="2-1-条件"><a href="#2-1-条件" class="headerlink" title="2.1 条件"></a>2.1 条件</h3><p>能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。</p>
<ol>
<li>无后效性</li>
</ol>
<p>已经求解的子问题，不会再受到后续决策的影响，即后续状态不会影响前序状态，也说明了求解的有序性。</p>
<ol start="2">
<li>子问题重叠</li>
</ol>
<p>子问题 A 和子问题 B 可能存在共同的子问题 C，那么我们可以将一些重叠的子问题存储下来，特别来说，重叠的越多，我们的空间利用率越高。</p>
<ol start="3">
<li>最优子结构</li>
</ol>
<p>当前问题的最优解一定可以由子问题的最优解导出。</p>
<p>再抽象一点，其实大部分的 DP 问题，都可以抽象为数字三角形问题，结构图如下：</p>
<p class='item-img' data-src='/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713337518314.png'><img src="/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713337518314.png" alt="图片描述"></p>
<p>箭头源代表子问题，箭头指向，代表后续问题。</p>
<p>例如：$\lbrace 1 \rbrace$ 同时是 $\lbrace 2,3 \rbrace$ 的子问题，并且 $2$ 问题的解可以由 $1$ 导出。</p>
<p>总结：<strong>动态规划对状态的遍历，构成了一张有向无环图，遍历顺序（或者求解顺序）应该是该图的一个拓扑序</strong>。</p>
<h2 id="3-关于比赛中的状态设计"><a href="#3-关于比赛中的状态设计" class="headerlink" title="3. 关于比赛中的状态设计"></a>3. 关于比赛中的状态设计</h2><p>DP 的难点在于状态的设计和子结构的发掘，即使学界讨论了诸多DP转移的状态设计和优化手段，但是如何把问题形式化为状态空间，往往是一件考察智力而非套路的事情。</p>
<p>但是在蓝桥杯的赛题中，考察的是选手的基本功，与一点点的拔高，所以不会太难，可以遵循某些套路。</p>
<p>笔者按照经验，先讲授一些自己常用的状态设计思路，然后结合例题讲解。</p>
<p>设计一个状态分为如下几步：</p>
<ol>
<li>尝试找到题目中的需要优化的值，例如最小值，最大值，次数等，做为目标，也是就是状态的最优值。</li>
<li>尝试找到题目中的条件，例如长度，区间数量等，做为状态设计。</li>
<li>尝试模拟题目中的求解步骤，这往往是题目中的条件，例如对某个数加一，或者在占领某些土地。作为转移的部分。</li>
<li>尝试结合将 1，2，3 结合起来，看能否找到一个合理的最优结构，并且无后向性。</li>
<li>如果不是最优，尝试这加大状态的条件，例如在补上一个必要的量，在进行3步骤。</li>
</ol>
<p>笔者还有一些习惯，例如在看到某个题目时，如果准备尝试用DP解题，就是按照题目中的量进行一个简单尝试。例如，题目中有三个量，就会尝试写出 $dp_{i,j,k}$ ，然后尝试读出其代表的实际意义。如果可行，就进行优化或者细化。</p>
<p>一般而言，常见的线性DP，都能用此种方法解决，对于较难的问题，往往很难一下子设计出一个较好的状态，这就需要大量的经验以及一些天赋。</p>
<p>例如，你可以尝试设计这两个问题的状态：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/3601/learning/">蓝桥云课-青蛙吃虫</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/17004/learning/">蓝桥算法赛-食堂</a></p>
</li>
</ol>
<p>可以很明显的感觉出设计的难点。</p>
<h2 id="4-线性DP"><a href="#4-线性DP" class="headerlink" title="4. 线性DP"></a>4. 线性DP</h2><p>本部分将结合一些题，来不断的重复上述建立 DP 状态的方法，意图帮助读者强化一些简单的DP状态设计。</p>
<h3 id="4-1-蓝桥云课-青蛙吃虫"><a href="#4-1-蓝桥云课-青蛙吃虫" class="headerlink" title="4.1 蓝桥云课-青蛙吃虫"></a>4.1 <a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/3601/learning/">蓝桥云课-青蛙吃虫</a></h3><p class='item-img' data-src='/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713337799031.png'><img src="/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713337799031.png" alt="图片描述"></p>
<ol>
<li>找到题目中的需要优化的值，“最多吃多少昆虫”，完美符合要求，我们将这个最大值作为状态的最优值，也就是说，如果我们设计了一个状态 $s$，那么我们的 $dp_s$ 所代表的意义大概率在 $s$ 情况下的吃虫的最大虫数。</li>
<li>尝试找到题目中的条件，路径长度为 $N$，最多跳 $K$ 次。</li>
<li>尝试模拟题目中的求解步骤，这往往是题目中的条件。每次跳 $T$ 格，但是满足 $A \le T \le B$，可以看作跳一次，就是一次转移。</li>
</ol>
<p>尝试结合将 1，2，3 结合起来，看能否找到一个合理的最优结构，并且无后向性。</p>
<blockquote>
<p>得到的状态以及转移如下：</p>
<p>定义 $dp_{i,j}$ 为跳跃了 $i$ 次后，当前处在 $j$ 位置能吃到的最大昆虫数量。</p>
<p>那么由定义得到 $dp_{0,0} &#x3D; 0$，这是初始状态，代表的意义是在未跳跃前的状态，很明显符合定义（初始状态的定义，往往是需要对应于真实情况）。</p>
<p>我们思考如何转移，由于转移的过程为题目中的求解条件：每次跳跃一些格子，那么跳跃就是转移的过程。</p>
<p>我们思路如何得到 $dp_{i,j}$ ，复习定义：跳跃了 $i$ 次后，当前处在 $j$ 位置能吃到的最大昆虫数量。</p>
<p>那么这个状态的前一个状态是什么，也是就说，他的子问题是什么，根据实际情况，我们可以得到上一个状态一定是 $dp_{i-1,j’}$，定义为 跳跃了 $i-1$ 次后，到达位置为 $j’$ 的位置，如果满足跳一次可以到达 $j$，那么必须满足 $A \le j-j’ \le B$。</p>
</blockquote>
<p>有了这个过程，那么我们实际上就得到了转移的逻辑，你完全可以根据这个思路写出代码核心：</p>
<ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dp)); <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= K; ++i) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = A; k &lt;= B; ++k) &#123; <span class="hljs-keyword">if</span> (j - k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - k] + a[j]); &#125; ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : dp) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; row.length; j++) &#123; row[j] = -<span class="hljs-number">0x3f3f3f3f</span>; &#125; &#125; dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= K; ++i) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> A; k &lt;= B; ++k) &#123; <span class="hljs-keyword">if</span> (j - k &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; dp[i][j] = Math.max(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - k] + a[j]); &#125; ans = Math.max(ans, dp[i][j]); &#125; &#125; System.out.println(ans);<br></code></pre></td></tr></table></figure>

<ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, K + <span class="hljs-number">1</span>): <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>): <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(A, B + <span class="hljs-number">1</span>): <span class="hljs-keyword">if</span> j - k &lt; <span class="hljs-number">0</span>: <span class="hljs-keyword">continue</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - k] + a[j]) ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]) <span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure>

<p>我们可以写出更具规整的转移： $dp_{0,0} &#x3D; 0 \ dp_{i,j} &#x3D; \max_{A \le k \le B}(dp_{i-1,k})$ 我们要求的答案为 $\underset{0 \le i \le k, 0 \le j \le n}{\max}(dp_{i,j})$。</p>
<h3 id="4-2-蓝桥算法赛-奇怪的段"><a href="#4-2-蓝桥算法赛-奇怪的段" class="headerlink" title="4.2 蓝桥算法赛-奇怪的段"></a>4.2 <a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/12112/learning/">蓝桥算法赛-奇怪的段</a></h3><p class='item-img' data-src='/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713337554344.png'><img src="/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713337554344.png" alt="图片描述"></p>
<p>我们继续重复上述解题方法：</p>
<ol>
<li><p>找到题目中的需要优化的值，“加权和值最大”，完美符合要求，我们将这个最大值作为状态的最优值，也就是说，如果我们设计了一个状态 $s$，那么我们的 $dp_s$ 所代表的意义大概率在 $s$ 情况下的最大加权和值。</p>
</li>
<li><p>尝试找到题目中的条件，序列长度为 $n$，划分出 $k$ 个区间。</p>
</li>
<li><p>尝试模拟题目中的求解步骤，这往往是题目中的条件。在本题中，划分区间就是一次转移。</p>
</li>
<li><p>尝试结合将1，2，3结合起来，看能否找到一个合理的最优结构，并且无后向性。</p>
</li>
</ol>
<p>我们可以尝试建立如下转移：</p>
<blockquote>
<p>定义状态 $dp_{i,j}$ 表示处理到第 $i$ 个数字，分出 $j$ 个区间的最大值。</p>
<p>初始状态为 $dp_{0,0} &#x3D; 0$。这个代表初始情况下，未划分区间的最大值，是符合实际情况，并且是符合定义的。</p>
<p>由于一次划分就是一次转移，我们考虑 $dp_{i,j}$，他的上一次划分一定是 $dp_{i’,j-1}$，所代表的意义是，划分 $j-1$ 段时，最后一个元素是 $i$ 的情况。</p>
<p>那么我们的转移就是 $dp_{i,j} &#x3D; dp_{i’,j-1} + p_j \times \sum _{y&#x3D;i’+1} ^i a_y$。</p>
<p>当然，我们要求的是最大值，所以我们需要加一个条件： $dp_{i,j} &#x3D; \underset {j \le i’ \le i} {\max}  (dp_{i’,j-1} + p_j \times \sum _{y&#x3D;i’+1} ^i a_y)$ 状态是 $n \times k$ 个，每次转移的代价是 $n$ 次，那么这个转移的复杂度为 $O(n^2 \times k)$。</p>
<p>当然，对于这个题来说，复杂度太高了，无法通过本题，由于是算法赛，所以无法通过，<strong>如果是蓝桥大赛的题，那么大概率能得到 $50$ % 的分数。</strong> 当然需要一些优化策略，不然求和的这一部分也会增加复杂度，同学们自行思考（提示：前缀和，或者边循环边算）。</p>
<p>如果要解决本题，我们考虑优化</p>
<p>将式子拆开</p>
<p class='item-img' data-src='/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713348601655.png'><img src="/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713348601655.png" alt="图片描述"></p>
<p>上述的理解为，将 $a_i$ 新开一个区间，还是并入旧区间。</p>
<p>转移的复杂度为：$O(n\times k)$。</p>
<p>实现过程中用了滚动数组，用来节约空间，当然也可以不用。</p>
<p>滚动数组： 由于每次转移 $dp_{i,j}$ 只与 $dp_{i-1, j’}$ 有关，对于第一维来说， $dp_i$ 只与 $dp_{i-1}$ 有关，所以，我们用两个量来表示当前的 $dp_i$ 和 $dp_{i-1}$ 即可。在代码中用 $dp_{now}$ 和 $dp_{pre}$ 表示。</p>
</blockquote>
<p>代码如下：</p>
<ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> using namespace std; const int N = 1e5+100; using ll = long long; ll dp[2][204]; int n, k; int a[N], b[204]; int main() &#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i <span class="hljs-string">&lt;= n; ++i) cin &gt;</span>&gt; a[i]; for (int i = 1; i <span class="hljs-string">&lt;= k; ++i) cin &gt;</span>&gt; b[i]; memset(dp, -0x3f, sizeof(dp)); int now = 0, pre = 1; dp[now][0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; swap(now, pre); memset(dp[now], -0x3f, sizeof(dp[now])); for (int j = 1; j &lt;= k; ++j) &#123; dp[now][j] = max(dp[pre][j], dp[pre][j - 1]) + 1ll * a[i] * b[j]; &#125; &#125; cout &lt;&lt; dp[now][k] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; return 0; &#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span> &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in); <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100500</span>; <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][<span class="hljs-number">205</span>]; <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt(); <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> scanner.nextInt(); <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N]; <span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">205</span>]; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123; a[i] = scanner.nextInt(); &#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123; b[i] = scanner.nextInt(); &#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">205</span>; ++i) dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">1</span>][i] = -<span class="hljs-number">9000000000000000000L</span>; dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123; now ^= <span class="hljs-number">1</span>; pre ^= <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">205</span>; ++j) dp[now][j] = -<span class="hljs-number">9000000000000000000L</span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123; dp[now][j] = Math.max(dp[pre][j], dp[pre][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1L</span> * a[i] * b[j]; &#125; &#125; System.out.println(dp[now][k]); &#125; &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-number">100500</span> dp = [[-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * <span class="hljs-number">205</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)] n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()) a = [<span class="hljs-number">0</span>] + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) b = [<span class="hljs-number">0</span>] + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) now, pre = <span class="hljs-number">0</span>, <span class="hljs-number">1</span> dp[now][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>): now, pre = pre, now dp[now] = [-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * <span class="hljs-number">205</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>): dp[now][j] = <span class="hljs-built_in">max</span>(dp[pre][j], dp[pre][j - <span class="hljs-number">1</span>]) + a[i] * b[j] <span class="hljs-built_in">print</span>(dp[now][k])<br></code></pre></td></tr></table></figure>

<h2 id="5-背包"><a href="#5-背包" class="headerlink" title="5. 背包"></a>5. 背包</h2><p>背包问题是老生常谈的经典问题了。</p>
<p>原始模型如下：</p>
<p>有 $n$ 个物品和一个容量为 $m$ 的背包，每个物品有一个价值 $p$ 和 体积 $v$ 。问在总容量不超过 $m$ 的情况下，你能装载的最大价值和为多少？</p>
<p>背包有多种模型：</p>
<ol>
<li>0&#x2F;1 背包，在这种情况下，每个物品只有一个。</li>
<li>完全背包，在这种情况下，每个物品有无穷个。</li>
<li>多重背包，在这种情况下，每个物品有 $c_i$ 个，$c_i$ 为第 $i$ 个物品的数量。</li>
<li>分组背包，在这种情况下，存在 $n$ 个组别，每个组别有若干个物品，但是每组至多只能选择一个。</li>
<li>依赖背包，在这种情况下，某些物品之间存在依赖关系。</li>
</ol>
<p>最基础的属于 0&#x2F;1 背包和完全背包。</p>
<p>其模板代码如下：</p>
<h3 id="5-1-0-1-背包"><a href="#5-1-0-1-背包" class="headerlink" title="5.1 0&#x2F;1 背包"></a>5.1 0&#x2F;1 背包</h3><ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二维数组版本 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m; j - v[i] &gt;= 0; --j) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + p[i]); &#125; &#125; // ------------- 一维数组版本 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m; j - v[i] &gt;= 0; --j) &#123; dp[j] = max(dp[j], dp[j - v[i]] + p[i]); &#125; &#125; // dp[i][j] 代表处理到第 i 个物品，容量为 j 时的最大值。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二维数组版本 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m; j - v[i] &gt;= 0; --j) &#123; dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - v[i]] + p[i]); &#125; &#125; // ------------- 一维数组版本 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m; j - v[i] &gt;= 0; --j) &#123; dp[j] = Math.max(dp[j], dp[j - v[i]] + p[i]); &#125; &#125; // dp[i][j] 代表处理到第 i 个物品，容量为 j 时的最大值。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二维数组版本 for i in range(1, n + 1): for j in range(m, v[i] - 1, -1): dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + p[i]) # ------------- 一维数组版本 for i in range(1, n + 1): for j in range(m, v[i] - 1, -1): dp[j] = max(dp[j], dp[j - v[i]] + p[i])</span><br></code></pre></td></tr></table></figure>

<h3 id="5-2-完全背包"><a href="#5-2-完全背包" class="headerlink" title="5.2 完全背包"></a>5.2 完全背包</h3><ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ------------- 一维数组版本 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = v[i]; j &lt;= m; ++j) &#123; dp[j] = max(dp[j], dp[j - v[i]] + p[i]); &#125; &#125; // dp[i][j] 代表处理到第 i 个物品，容量为 j 时的最大值。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ------------- 一维数组版本 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = v[i]; j &lt;= m; ++j) &#123; dp[j] = Math.max(dp[j], dp[j - v[i]] + p[i]); &#125; &#125; // dp[i][j] 代表处理到第 i 个物品，容量为 j 时的最大值。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>): <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(v[i], m + <span class="hljs-number">1</span>): dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + p[i])<br></code></pre></td></tr></table></figure>

<h3 id="5-3-多重背包"><a href="#5-3-多重背包" class="headerlink" title="5.3 多重背包"></a>5.3 多重背包</h3><p>多重背包可以转化为 $0&#x2F;1$ 背包。</p>
<p>首先我们可以将每个物品的 $c_i$ 个全部拆出来，变成0&#x2F;1 背包，但是这样的话复杂度就变成了 $O(m \times \sum c_i)$。</p>
<p>还有另外一种方式，我们可以将 $c_i$ 按照进制拆分，分为 $\lbrace 1, 2, 4, 8, … \rbrace$ 个，例如，如果是 $5$ 个，每个物品的容量为 $v$，价值为 $p$，那么划分为 $\lbrace 1, 2, 2\rbrace$，将这 $5$ 个物品划分为 $3$ 个物品，第一个物品容量为 $v$，价格为 $p$，第二个物品容量为 $2v$，价格为 $2p$，第三个物品容量为 $2v$，价格为 $2p$，这样就将复杂度降低为了 $O(m \sum \log_2(c_i))$。</p>
<blockquote>
<p>这样的划分，可以拼凑出 $0 \sim c_i$ 所有数量的物品。因为是按照二进制划分的，假设划分的最大数量是 $2^k$，那么最后一个是 $x &#x3D; c_i-2^{k+1} + 1$。</p>
<p>我们首先可以用前 $k$ 个拼凑出 $0 \sim 2 ^{k+1} - 1$ 种情况，并且 $x \lt 2^{k+1}$，所以其他数可以先加上 $x$ ，然后再加上 $0 \sim 2^{k+1} - 1$ 中的一个，那么就可以拼凑出 $0 \sim c_i$ 所有的数量了。</p>
</blockquote>
<p>拆分代码：</p>
<ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// index 为新的物品编号 index = 0; for (int i = 1; i &lt;= m; i++) &#123; int cnt = 1, p, v, c; cin &gt;&gt; p &gt;&gt; v &gt;&gt; c; while (c &gt; cnt) &#123; c -= cnt; list[++index].p = c * p; list[index].v = c * v; cnt *= 2; &#125; list[++index].p = c * p; list[index].v = c * v; &#125; // list 存储所有新的物品</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m): cnt = <span class="hljs-number">1</span> p, v, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()) <span class="hljs-keyword">while</span> c &gt; cnt: c = c - cnt <span class="hljs-built_in">list</span>.append((c * p, c * v)) cnt = cnt * <span class="hljs-number">2</span> <span class="hljs-built_in">list</span>.append((c * p, c * v))<br></code></pre></td></tr></table></figure>

<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in); p = scanner.nextInt(); v = scanner.nextInt(); c = scanner.nextInt(); <span class="hljs-keyword">while</span> (c &gt; cnt) &#123; c -= cnt; index++; list[index].p = c * p; list[index].v = c * v; cnt *= <span class="hljs-number">2</span>; &#125; index++; list[index].p = c * p; list[index].v = c * v;<br></code></pre></td></tr></table></figure>

<h4 id="5-3-1-小明的背包4"><a href="#5-3-1-小明的背包4" class="headerlink" title="5.3.1 小明的背包4"></a>5.3.1 <a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/1177/learning/">小明的背包4</a></h4><p class='item-img' data-src='/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713349006255.png'><img src="/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713349006255.png" alt="图片描述"></p>
<p>算是一个多重背包模板题，套用上述模板解题即可。</p>
<p>当然，本题中存在无限的数量，可以有两种考虑方法，对于无穷数量，我们定义会满载的数量，例如 $\frac{V}{w_i}$；或者在分完多重背包后，在进行完全背包。</p>
<p>都可以，推荐同学们两种都试试。</p>
<ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> using namespace std; int idx = 0; int w[40003], v[40003]; int N, V; int dp[2003]; int main() &#123; cin &gt;&gt; N &gt;&gt; V; int ww, vv, c; while (N --) &#123; cin &gt;&gt; ww &gt;&gt; vv &gt;&gt; c; <span class="hljs-keyword">if</span> (c == 0) c = V / ww; int cnt = 1; while (c &gt; cnt) &#123; idx ++; c -= cnt; w[idx] = cnt * ww; v[idx] = cnt * vv; cnt *= 2; &#125; idx ++; w[idx] = c * ww; v[idx] = c * vv; &#125; for (int i = 1; i <span class="hljs-string">&lt;= idx; ++i) &#123; for (int j = V; j - w[i] &gt;</span>= 0; --j) &#123; dp[j] = max(dp[j], dp[j - w[i]] + v[i]); &#125; &#125; cout &lt;&lt; dp[V] &lt;&lt; endl; return 0; &#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span> &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in); <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-type">int</span>[] w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">40003</span>]; <span class="hljs-type">int</span>[] v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">40003</span>]; <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> scanner.nextInt(); <span class="hljs-type">int</span> <span class="hljs-variable">V</span> <span class="hljs-operator">=</span> scanner.nextInt(); <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2003</span>]; <span class="hljs-keyword">while</span> (N-- &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-type">int</span> <span class="hljs-variable">ww</span> <span class="hljs-operator">=</span> scanner.nextInt(); <span class="hljs-type">int</span> <span class="hljs-variable">vv</span> <span class="hljs-operator">=</span> scanner.nextInt(); <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> scanner.nextInt(); <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) c = V / ww; <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span> (c &gt; cnt) &#123; idx++; c -= cnt; w[idx] = cnt * ww; v[idx] = cnt * vv; cnt *= <span class="hljs-number">2</span>; &#125; idx++; w[idx] = c * ww; v[idx] = c * vv; &#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= idx; ++i) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> V; j - w[i] &gt;= <span class="hljs-number">0</span>; --j) &#123; dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]); &#125; &#125; System.out.println(dp[V]); &#125; &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idx = <span class="hljs-number">0</span> w = [<span class="hljs-number">0</span>] * <span class="hljs-number">40003</span> v = [<span class="hljs-number">0</span>] * <span class="hljs-number">40003</span> N, V = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()) dp = [<span class="hljs-number">0</span>] * <span class="hljs-number">2003</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N): ww, vv, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()) <span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>: c = V // ww cnt = <span class="hljs-number">1</span> <span class="hljs-keyword">while</span> c &gt; cnt: idx += <span class="hljs-number">1</span> c -= cnt w[idx] = cnt * ww v[idx] = cnt * vv cnt *= <span class="hljs-number">2</span> idx += <span class="hljs-number">1</span> w[idx] = c * ww v[idx] = c * vv <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, idx + <span class="hljs-number">1</span>): <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V, w[i] - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>): dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]) <span class="hljs-built_in">print</span>(dp[V])<br></code></pre></td></tr></table></figure>

<h3 id="5-4-分组背包"><a href="#5-4-分组背包" class="headerlink" title="5.4 分组背包"></a>5.4 分组背包</h3><p>给定 $n$ 组物品，第 $i$ 组中有 $c_i$ 个物品，第 $i$ 组中第 $j$ 个物品的价值为 $p_{i,j}$ ，体积为 $v_{i,j}$，每组物品最多只能选择一个。</p>
<p>背包大小为 $m$ ，问装载的最大价值。</p>
<p>这个问题与原始的 $0&#x2F;1$ 背包十分相似，复习下，原始的 $0&#x2F;1$ 背包如何建立的状态转移：$dp_{i,j}$ 为处理到第 $i$ 个物品，装载体积为 $j$ 的最大价值。</p>
<p>其转移为 $dp_{i,j} &#x3D; \max(dp_{i-1, j} , dp_{i-1,j-v_i} + p_i)$</p>
<p>我们只要稍作思考，就可以完成转化：</p>
<p>我们定义：$dp_{i,j}$ 为处理到第 $i$ <strong>组</strong>物品，装载体积为 $j$ 的最大价值。</p>
<p>那么转移为： $dp_{i,j} &#x3D; \max(dp_{i-1, j} , \max_{1 \le j \le c_i}(dp_{i-1,j-v_{i,j}} + p_{i,j}))$ 观察到了吗，这两种甚至没有区别，只有再处理每一组的过程中进行了一次选择，逻辑通顺，完美转移！</p>
<p>我们来看一道例题：</p>
<h4 id="5-4-1-金明的预算"><a href="#5-4-1-金明的预算" class="headerlink" title="5.4.1 金明的预算"></a>5.4.1 <a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/558/learning/">金明的预算</a></h4><p class='item-img' data-src='/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713347341038.png'><img src="/./../images/%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/uid1792586-20240417-1713347341038.png" alt="图片描述"></p>
<p>我们简化一下题意：</p>
<p>有 $m$ 块钱，$n$ 件物品，每个物品的价值为 $p_i \times v_i$，价格为 $v_i$。有一些物品存在依赖关系，想要购买当前物品，就一定要购买前置物品。</p>
<p>问能购买的最大价值。</p>
<p><strong>条件</strong>：每一件物品最多只有<strong>两件</strong>附属物品。</p>
<p>看起来是一个依赖有关的背包问题，但是仔细思考就会发现，如果 $A$ 物品有两件附属物品 $B,C$，那么对于这三件物品，只有这么几种情况 $\lbrace \varnothing \rbrace,\lbrace A \rbrace,\lbrace A,B \rbrace,\lbrace A, C \rbrace,\lbrace A, B, C \rbrace$，并且对于这三个物品的组合，只能选择<strong>一种</strong>。对于有一个附属物品和没有附属物品的情况，类似考虑。</p>
<p>回过头来，是不是发现，很想分组背包的感觉。</p>
<p>我们重新描绘一下题意：</p>
<p>有 $m$ 块钱，$n$ 组物品，每组物品数量不超过三，每个物品有价值、价格。每组物品只能选择<strong>一种</strong>组合。问能购买的最大价值。</p>
<p>完美转换为分组背包。</p>
<p>代码如下：</p>
<ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> using namespace std; int n, m; vector<span class="hljs-string">&lt;int&gt;</span> G[65]; int v[65], p[65], q[65]; int dp[33000]; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i <span class="hljs-string">&lt;= m; ++i) &#123; cin &gt;</span>&gt; v[i] &gt;&gt; p[i] &gt;&gt; q[i]; p[i] *= v[i]; <span class="hljs-keyword">if</span> (q[i]) &#123; G[q[i]].push_back(i); &#125; &#125; for (int i = 1; i <span class="hljs-string">&lt;= m; ++i) &#123; if (q[i] == 0) &#123; for (int j = n; j &gt;</span>= 0; --j) &#123; <span class="hljs-keyword">if</span> (j - v[i] &gt;= 0) dp[j] = max(dp[j], dp[j - v[i]] + p[i]); <span class="hljs-keyword">if</span> (G[i].size() &gt; 0 &amp;&amp; j - v[i] - v[G[i][0]] &gt;= 0) dp[j] = max(dp[j], dp[j - v[i] - v[G[i][0]]] + p[i] + p[G[i][0]]); <span class="hljs-keyword">if</span> (G[i].size() &gt; 1 &amp;&amp; j - v[i] - v[G[i][1]] &gt;= 0) dp[j] = max(dp[j], dp[j - v[i] - v[G[i][1]]] + p[i] + p[G[i][1]]); <span class="hljs-keyword">if</span> (G[i].size() &gt; 1 &amp;&amp; j - v[i] - v[G[i][0]] - v[G[i][1]] &gt;= 0) dp[j] = max(dp[j], dp[j - v[i] - v[G[i][0]] - v[G[i][1]]] + p[i] + p[G[i][0]] + p[G[i][1]]); &#125; &#125; &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; return 0; &#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList; <span class="hljs-keyword">import</span> java.util.List; <span class="hljs-keyword">import</span> java.util.Scanner; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123; <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n, m; <span class="hljs-keyword">static</span> List&lt;Integer&gt;[] G = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[<span class="hljs-number">65</span>]; <span class="hljs-comment">// 使用ArrayList数组来表示图 static int[] v = new int[65], p = new int[65], q = new int[65]; static int[] dp = new int[33000]; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); m = scanner.nextInt(); // 初始化G数组 for (int i = 0; i &lt; G.length; i++) &#123; G[i] = new ArrayList&lt;&gt;(); &#125; for (int i = 1; i &lt;= m; i++) &#123; v[i] = scanner.nextInt(); p[i] = scanner.nextInt(); q[i] = scanner.nextInt(); p[i] *= v[i]; if (q[i] != 0) &#123; G[q[i]].add(i); // 将后继节点i添加到q[i]的列表中 &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; if (q[i] == 0) &#123; for (int j = n; j &gt;= 0; j--) &#123; if (j - v[i] &gt;= 0) dp[j] = Math.max(dp[j], dp[j - v[i]] + p[i]); // 处理后继节点 for (int k = 0; k &lt; G[i].size(); k++) &#123; int nextItem = G[i].get(k); if (j - v[i] - v[nextItem] &gt;= 0) &#123; dp[j] = Math.max(dp[j], dp[j - v[i] - v[nextItem]] + p[i] + p[nextItem]); &#125; &#125; if (G[i].size() &gt; 1) &#123; int p1 = G[i].get(0), p2 = G[i].get(1); if (j - v[i] - v[p1] - v[p2] &gt;= 0) &#123; dp[j] = Math.max(dp[j], dp[j - v[i] - v[p1] - v[p2]] + p[i] + p[p1] + p[p2]); &#125; &#125; &#125; &#125; &#125; System.out.println(dp[n]); scanner.close(); &#125; &#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()) G = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>)] v = [<span class="hljs-number">0</span>] * <span class="hljs-number">65</span> p = [<span class="hljs-number">0</span>] * <span class="hljs-number">65</span> q = [<span class="hljs-number">0</span>] * <span class="hljs-number">65</span> dp = [<span class="hljs-number">0</span>] * <span class="hljs-number">33000</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>): v[i], p[i], q[i] = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()) p[i] *= v[i] <span class="hljs-keyword">if</span> q[i]: G[q[i]].append(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>): <span class="hljs-keyword">if</span> q[i] == <span class="hljs-number">0</span>: <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>): <span class="hljs-keyword">if</span> j - v[i] &gt;= <span class="hljs-number">0</span>: dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + p[i]) <span class="hljs-keyword">if</span> G[i]: <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(G[i])): <span class="hljs-keyword">if</span> j - v[i] - v[G[i][k]] &gt;= <span class="hljs-number">0</span>: dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i] - v[G[i][k]]] + p[i] + p[G[i][k]]) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(G[i]) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j - v[i] - v[G[i][<span class="hljs-number">0</span>]] - v[G[i][<span class="hljs-number">1</span>]] &gt;= <span class="hljs-number">0</span>: dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i] - v[G[i][<span class="hljs-number">0</span>]] - v[G[i][<span class="hljs-number">1</span>]]] + p[i] + p[G[i][<span class="hljs-number">0</span>]] + p[G[i][<span class="hljs-number">1</span>]]) <span class="hljs-built_in">print</span>(dp[n])<br></code></pre></td></tr></table></figure>

<h2 id="6-依赖背包"><a href="#6-依赖背包" class="headerlink" title="6. 依赖背包"></a>6. 依赖背包</h2><p>这个比较复杂，一般来讲是树形的依赖关系，我们放在树形DP再讲。</p>
<h2 id="7-作业"><a href="#7-作业" class="headerlink" title="7. 作业"></a>7. 作业</h2><table>
<thead>
<tr>
<th>考点</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>线性 DP</td>
<td><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2114/learning/">李白打酒-真题</a></td>
</tr>
<tr>
<td>线性 DP</td>
<td><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/3545/learning/">保险箱-真题</a></td>
</tr>
<tr>
<td>背包问题</td>
<td><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/5130/learning/">健身-算法赛</a></td>
</tr>
<tr>
<td>背包问题</td>
<td><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/98/learning/">包子凑数</a></td>
</tr>
</tbody></table>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/05/06/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B8%E5%9E%8B%E9%A2%98%E5%9E%8B%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/">← Next 状态压缩动态规划的典型题型深入分析</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/04/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">算法竞赛入门经典（第2版）学习记录 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">zdx</a></h1><div id="description"><p>learn</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/zdx-1"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="mailto:19546328912@163.com"><i class="fa fa-envelope" alt="E-Mail"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/353147531"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DP-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. DP 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8A%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">2. 主要思想以及条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E4%BA%8E%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">3. 关于比赛中的状态设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BA%BF%E6%80%A7DP"><span class="toc-number">4.</span> <span class="toc-text">4. 线性DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%93%9D%E6%A1%A5%E4%BA%91%E8%AF%BE-%E9%9D%92%E8%9B%99%E5%90%83%E8%99%AB"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 蓝桥云课-青蛙吃虫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%93%9D%E6%A1%A5%E7%AE%97%E6%B3%95%E8%B5%9B-%E5%A5%87%E6%80%AA%E7%9A%84%E6%AE%B5"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 蓝桥算法赛-奇怪的段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%83%8C%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">5. 背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-0-1-%E8%83%8C%E5%8C%85"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 0&#x2F;1 背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 多重背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E5%B0%8F%E6%98%8E%E7%9A%84%E8%83%8C%E5%8C%854"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 小明的背包4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 分组背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 金明的预算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BE%9D%E8%B5%96%E8%83%8C%E5%8C%85"><span class="toc-number">6.</span> <span class="toc-text">6. 依赖背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BD%9C%E4%B8%9A"><span class="toc-number">7.</span> <span class="toc-text">7. 作业</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>